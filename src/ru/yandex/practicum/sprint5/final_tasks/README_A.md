# ПРИНЦИП РАБОТ
1. Создаём бинарную кучу и добавляем в неё каждый элемент применяя метод "просеивания вверх" (помещаем приоритетеные элементы в начало).
2. Извлекаем из кучи наиболее приоритетные элементы. Оставшуюся часть необходимо отсортировать просеиванием вниз. Действие повторяем до полной сортировки.

Статья на хабре https://habr.com/ru/companies/edison/articles/495420/

# ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
Массив отсортирован.

# ВРЕМЕННАЯ СЛОЖНОСТЬ
`O(n * log n)` - первое просеивание вверх.
Затем повторяем просеивание вниз за `O(n * log n)`.
В итоге получается два прохода - `O(n * log n)` + `O(n * log n)`, что есть `O(n * log n)`.

# ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
`O(1)` - массив уже является деревом. Нет необходимости отдельно хранить какие-то элементы.

Андрей, во-первых, большое спасибо за замечания и комметарии, которые вы делаете. Ниже приведу ответ на ваш вопрос.
> А что делать с тем, что все просеивания рекурсивно сделаны?

Тут мы возвращаемся к вопросу про прастранственную сложность в рекурсии, который я задавал несколько спринтов ранее.
Как я понял из обзора литературы, сложность по дополнительной памяти = `O(1)`, т.к. всё происходит сразу на месте.
Можно найти много ссылок на научные публикации в Google Scholar, в которых указанно именно так.
[Вот один из примеров](https://www.researchgate.net/profile/Christos-Zaroliagis/publication/228868535_Heapsort_using_Multiple_Heaps/links/53e255f80cf216e8321a9335/Heapsort-using-Multiple-Heaps.pdf)
Цитата: Heapsort belongs to the family of algorithms that sort by selection and requires O(1) auxiliary space, falling into the category of in-place algorithms.
Так же на Хабре есть интересная статья, на которую многие любят ссылаться. [Тут](https://habr.com/ru/articles/188010/).
Если же я что-то не понимаю (а это вполне может быть! :) ), просто объяснить или скинуть ссылку.